<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flashy for Islay</title>
  <style>
    :root { color-scheme: light; }
    body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:#fff; color:#111; }
    .wrap{ max-width:860px; margin:0 auto; padding:16px 14px 26px; }
    header{ display:flex; gap:10px 14px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; margin-bottom:12px; }
    .title{ font-size:16px; font-weight:600; letter-spacing:0.2px; }
    .bar{ display:flex; flex-wrap:wrap; gap:8px 10px; align-items:center; }
    label{ font-size:12px; color:#444; }
    select{ padding:6px 8px; border:1px solid #bbb; border-radius:8px; background:#fff; color:#111; min-width:260px; font-size:14px; }
    button{ padding:8px 12px; border:1px solid #bbb; border-radius:10px; background:#fff; color:#111; cursor:pointer; font-size:14px; }
    button:focus, select:focus, input:focus { outline:2px solid #333; outline-offset:2px; }
    .modes{ display:flex; flex-wrap:wrap; gap:10px 14px; align-items:center; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:12px; }
    .modes .group{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .modes .sep{ width:1px; height:22px; background:#ddd; }
    .small{ font-size:12px; color:#555; }
    .card{ border:1px solid #bbb; border-radius:16px; padding:22px 18px; min-height:220px; display:flex; flex-direction:column; justify-content:center; user-select:none; background:#fff; }
    .card.state-0{ border-color:#bbb; }
    .card.state-1{ border-color:#b38b00; }
    .card.state-2{ border-color:#1f7a2e; }
    .side{ font-size:12px; color:#555; margin-bottom:8px; text-transform:uppercase; letter-spacing:0.08em; display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .text{ font-size:20px; line-height:1.35; white-space:pre-wrap; word-break:break-word; }
    .text.big{ font-size:24px; }
    .extra{ margin-top:12px; font-size:13px; color:#444; line-height:1.4; }
    .extra.big{ font-size:15px; }
    .extra .label{ color:#666; font-size:12px; text-transform:uppercase; letter-spacing:0.06em; margin-right:6px; }
    .footer{ display:flex; flex-wrap:wrap; gap:10px 12px; align-items:center; justify-content:space-between; margin-top:12px; font-size:12px; color:#555; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .pill{ border:1px solid #ccc; border-radius:999px; padding:4px 10px; background:#fff; color:#333; font-size:12px; }
    .grid{ margin-top:12px; border:1px solid #ddd; border-radius:12px; padding:10px; }
    .gridHead{ display:flex; flex-wrap:wrap; gap:10px 12px; align-items:center; justify-content:space-between; margin-bottom:8px; }
    .boxes{ display:grid; grid-template-columns: repeat(10, 1fr); gap:3px; max-width:260px; }
    .box{ width:100%; aspect-ratio:1 / 1; border:1px solid #cfcfcf; border-radius:4px; position:relative; background:#fff; }
    .box.state-0{ background:#f2f2f2; border-color:#d2d2d2; }
    .box.state-1{ background:#ffd37a; border-color:#b38b00; }
    .box.state-2{ background:#a8e3b4; border-color:#1f7a2e; }
    .box.current{ outline:2px solid #111; outline-offset:1px; }
    .dot{ position:absolute; width:10px; height:10px; border-radius:999px; right:3px; top:3px; background:#b00020; opacity:0.85; }
    .overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.08); display:none; align-items:center; justify-content:center; padding:16px; }
    .modal{ background:#fff; border:1px solid #bbb; border-radius:14px; padding:14px 14px 12px; max-width:260px; width:100%; }
    .modal h2{ margin:0 0 6px 0; font-size:16px; }
    .modal p{ margin:0 0 10px 0; font-size:13px; color:#444; line-height:1.4; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <div class="title">Flashy for Islay</div>
      <div class="small">Keys: Space flip, ← back, → next, ↑ easy, ↓ hard</div>
    </div>
    <div class="bar">
      <label for="deckSelect">Deck</label>
      <select id="deckSelect" aria-label="Deck"></select>
      <button id="promptBtn" type="button" aria-pressed="false">Prompt: front</button>
      <button id="textBtn" type="button" aria-pressed="false">Text: normal</button>
    </div>
  </header>

  <div class="modes">
    <div class="group" role="group" aria-label="Session mode">
      <label><input type="radio" name="mode" value="timed" checked> Timed (10 mins)</label>
      <label><input type="radio" name="mode" value="allgreen"> All green</label>
      <span class="sep" aria-hidden="true"></span>
      <span class="pill" id="timerPill">10:00</span>
      <label><input type="checkbox" id="showRemaining" checked> Show remaining</label>
      <span class="sep" aria-hidden="true"></span>
      <button id="restartBtn" type="button">Restart session</button>
    </div>
  </div>

  <main>
    <div id="card" class="card state-0" role="button" tabindex="0" aria-label="Flashcard. Press Space to flip.">
      <div class="side">
        <span id="sideLabel">Front</span>
        <span class="pill" id="countPill">0 / 0</span>
      </div>
      <div id="cardText" class="text"></div>
      <div id="extraBox" class="extra" style="display:none;"></div>
    </div>

    <div class="footer">
      <div class="row">
<button id="flipBtn" type="button">Flip</button>
        <button id="nextBtn" type="button">Next</button>
        <span aria-hidden="true" style="width:1px;height:22px;background:#ddd;display:inline-block;"></span>
        <button id="easyBtn" type="button">Easy</button>
        <button id="hardBtn" type="button">Hard</button>
      </div>
      <div class="row">
        <span class="pill" id="progressPill">Seen 0 · Easy 0 · Hard 0</span>
        <span class="pill" id="remainingPill" style="display:inline-block;">Remaining 0</span>
      </div>
    </div>

    <section class="grid" aria-label="Session map">
      <div class="gridHead">
        <div class="small">amber = nearly got it | green = got it | red dot = brain fart, gimme again</div>
        <div class="small" id="mapMeta"></div>
      </div>
      <div id="boxes" class="boxes" aria-label="Card state boxes"></div>
    </section>
  </main>
</div>

<div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div class="modal">
    <h2 id="modalTitle">Session paused</h2>
    <p id="modalText"></p>
    <div class="row" style="justify-content:flex-end; gap:8px;">
      <button id="stopBtn" type="button">Stop</button>
      <button id="continueBtn" type="button">Continue</button>
    </div>
  </div>
</div>

<script>
  const HARD_INTERVAL = 3;

  let DATA = [];

  // Deck index and deck files are loaded from ./decks/index.json
let DECKS = [];

  async function loadDeckIndexAndData() {
    const res = await fetch('decks/index.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('Could not load decks/index.json');
    DECKS = await res.json();

    const deckEntries = DECKS.filter(d => d && d.kind === 'deck' && d.file);
    const allCards = [];
    for (const d of deckEntries) {
      const r = await fetch(d.file, { cache: 'no-store' });
      if (!r.ok) throw new Error('Could not load deck file: ' + d.file);
      const deckData = await r.json();
      if (deckData && Array.isArray(deckData.cards)) {
        allCards.push(...deckData.cards);
      }
    }
    DATA = allCards;
  }

const deckSelect = document.getElementById("deckSelect");
  const promptBtn = document.getElementById("promptBtn");
  const textBtn = document.getElementById("textBtn");

  const cardEl = document.getElementById("card");
  const sideLabel = document.getElementById("sideLabel");
  const cardText = document.getElementById("cardText");
  const extraBox = document.getElementById("extraBox");
  const countPill = document.getElementById("countPill");
  const nextBtn = document.getElementById("nextBtn");
  const flipBtn = document.getElementById("flipBtn");
  const easyBtn = document.getElementById("easyBtn");
  const hardBtn = document.getElementById("hardBtn");

  const progressPill = document.getElementById("progressPill");
  const remainingPill = document.getElementById("remainingPill");
  const showRemaining = document.getElementById("showRemaining");

  const timerPill = document.getElementById("timerPill");
  const restartBtn = document.getElementById("restartBtn");

  const boxesEl = document.getElementById("boxes");
  const mapMeta = document.getElementById("mapMeta");

  const overlay = document.getElementById("overlay");
  const modalTitle = document.getElementById("modalTitle");
  const modalText = document.getElementById("modalText");
  const stopBtn = document.getElementById("stopBtn");
  const continueBtn = document.getElementById("continueBtn");

  const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));

  // App state
  let shuffleEnabled = true;
  let promptBackFirst = false;
  let bigText = false;

  let currentDeckDef = null;
  let sessionCards = [];
  let mainQueue = [];
  let hardQueue = [];
  let hardMarkedById = {};
  let stateById = {};
  let seenById = {};
  let currentId = null;
  let showingBack = false;
  let drawCount = 0;

  // Timed mode
  const DEFAULT_SECONDS = 10 * 60;
  let mode = "timed";
  let secondsLeft = DEFAULT_SECONDS;
  let timerHandle = null;
  let paused = false;

  // Helpers
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  function fmtTime(totalSeconds) {
    const m = Math.floor(totalSeconds / 60);
    const s = totalSeconds % 60;
    return String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
  }
  function getMode() {
    const r = modeRadios.find(x => x.checked);
    return r ? r.value : "timed";
  }
  function updateRemainingVisibility() {
    remainingPill.style.display = showRemaining.checked ? "inline-block" : "none";
  }
  function deckCardsFromDef(def) {
    if (def.kind === "folder") return DATA.filter(c => c.subject === def.subject && c.deck !== "How to use");
    return DATA.filter(c => c.subject === def.subject && c.topic === def.topic && c.deck === def.deck);
  }
  function populateDeckSelect() {
    deckSelect.innerHTML = "";
    const bySubject = {};
    for (const d of DECKS) {
      const subj = d.subject || "Other";
      (bySubject[subj] ||= []).push(d);
    }
    Object.keys(bySubject).forEach((subj) => {
      const group = document.createElement("optgroup");
      group.label = subj;
      bySubject[subj].forEach((d) => {
        const opt = document.createElement("option");
        opt.value = JSON.stringify(d);
        opt.textContent = d.label;
        group.appendChild(opt);
      });
      deckSelect.appendChild(group);
    });
  }
  function setPromptUI() {
    promptBtn.textContent = promptBackFirst ? "Prompt: back" : "Prompt: front";
    promptBtn.setAttribute("aria-pressed", promptBackFirst ? "true" : "false");
  }
  function setTextUI() {
    textBtn.textContent = bigText ? "Text: big" : "Text: normal";
    textBtn.setAttribute("aria-pressed", bigText ? "true" : "false");
    cardText.classList.toggle("big", bigText);
    extraBox.classList.toggle("big", bigText);
  }

  function resetSessionState(cards) {
    sessionCards = cards.slice();
    stateById = {};
    seenById = {};
    hardQueue = [];
    hardMarkedById = {};
    drawCount = 0;
    showingBack = false;

    sessionCards.forEach(c => { stateById[c.id] = 0; });

    mainQueue = sessionCards.map(c => c.id).slice();
    if (shuffleEnabled) shuffleArray(mainQueue);

    currentId = mainQueue.length ? mainQueue[0] : null;
    if (currentId) seenById[currentId] = true;
    renderAll();
    checkAllGreenEnd();
  }

  function currentCard() {
    return sessionCards.find(c => c.id === currentId) || null;
  }
  function cardIndexInSession(id) {
    return sessionCards.findIndex(c => c.id === id);
  }
  function isGreen(id) { return stateById[id] === 2; }
  function hardContains(id) { return hardQueue.indexOf(id) !== -1; }
  function countGreen() { return Object.values(stateById).filter(v => v === 2).length; }
  function countSeen() { return Object.keys(seenById).length; }

  function nextFromQueues() {
    if (countGreen() >= sessionCards.length) return null;

    mainQueue = mainQueue.filter(id => !isGreen(id));

    drawCount += 1;
    const shouldPullHard = (drawCount % HARD_INTERVAL === 0) && hardQueue.length > 0;

    if (shouldPullHard) {
      const id = hardQueue.shift();
      if (id && !isGreen(id)) return id;
    }

    if (mainQueue.length > 0) {
      const pos = mainQueue.indexOf(currentId);
      const nextPos = (pos === -1) ? 0 : (pos + 1) % mainQueue.length;
      return mainQueue[nextPos];
    }

    mainQueue = sessionCards.map(c => c.id).filter(id => !isGreen(id));
    if (shuffleEnabled) shuffleArray(mainQueue);
    return mainQueue.length ? mainQueue[0] : null;
  }

  function prevInMainQueue() {
    if (!mainQueue.length) return currentId;
    const pos = mainQueue.indexOf(currentId);
    const prevPos = (pos === -1) ? 0 : (pos - 1 + mainQueue.length) % mainQueue.length;
    return mainQueue[prevPos];
  }

  function moveTo(id) {
    if (!id) return;
    currentId = id;
    showingBack = false;
    seenById[currentId] = true;
    renderAll();
    checkAllGreenEnd();
  }

  function flipCard() {
    if (!currentId) return;
    showingBack = !showingBack;
    renderCard();
  }
  function nextCard() { const id = nextFromQueues(); if (id) moveTo(id); }
  function prevCard() { const id = prevInMainQueue(); if (id) moveTo(id); }

  function markHard() {
    if (!currentId) return;
    if (!isGreen(currentId) && !hardContains(currentId)) hardQueue.push(currentId);
    hardMarkedById[currentId] = true;
    nextCard();
  }

  function markEasy() {
    if (!currentId) return;
    const st = stateById[currentId] ?? 0;
    if (st === 0) stateById[currentId] = 1;
    else if (st === 1) stateById[currentId] = 2;

    if (isGreen(currentId)) {
      mainQueue = mainQueue.filter(id => id !== currentId);
      hardQueue = hardQueue.filter(id => id !== currentId);
      hardMarkedById[currentId] = false;
    }
    nextCard();
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function renderCard() {
    const c = currentCard();
    if (!c) {
      sideLabel.textContent = "Front";
      cardText.textContent = "";
      extraBox.style.display = "none";
      cardEl.className = "card state-0";
      countPill.textContent = "0 / 0";
      return;
    }

    const st = stateById[c.id] ?? 0;
    cardEl.className = "card state-" + st;

    const promptFront = !promptBackFirst;
    const frontText = promptFront ? c.front : c.back;
    const backText  = promptFront ? c.back : c.front;

    sideLabel.textContent = showingBack ? "Back" : "Front";
    cardText.textContent = showingBack ? backText : frontText;

    const definitionSideVisible = promptBackFirst ? !showingBack : showingBack;

    if (definitionSideVisible && (c.use || (c.related && c.related.length))) {
      const parts = [];
      if (c.use) parts.push('<div><span class="label">In use</span>' + escapeHtml(c.use) + '</div>');
      if (c.related && c.related.length) parts.push('<div><span class="label">Normally used in relation to</span>' + escapeHtml(c.related.join(", ")) + '</div>');
      extraBox.innerHTML = parts.join("");
      extraBox.style.display = "block";
    } else {
      extraBox.style.display = "none";
    }

    const idx = cardIndexInSession(c.id);
    countPill.textContent = (idx >= 0 ? (idx + 1) : 0) + " / " + sessionCards.length;
  }

  function renderProgress() {
    const seen = countSeen();
    const green = countGreen();
    const hard = hardQueue.length;
    progressPill.textContent = "Seen " + seen + " · Easy " + green + " · Hard " + hard;
    remainingPill.textContent = "Remaining " + (sessionCards.length - green);
    updateRemainingVisibility();
  }

  function renderMap() {
    boxesEl.innerHTML = "";
    sessionCards.forEach((c) => {
      const st = stateById[c.id] ?? 0;
      const box = document.createElement("div");
      box.className = "box state-" + st + (c.id === currentId ? " current" : "");
      if ((hardMarkedById[c.id] === true) && !isGreen(c.id)) {
        const dot = document.createElement("div");
        dot.className = "dot";
        box.appendChild(dot);
      }
      boxesEl.appendChild(box);
    });
    mapMeta.textContent = "Cards " + sessionCards.length;
  }

  function renderAll() {
    renderCard();
    renderProgress();
    renderMap();
  }

  // Timer and modal
  function stopTimer() { if (timerHandle) { clearInterval(timerHandle); timerHandle = null; } }

  function startTimer() {
    stopTimer();
    secondsLeft = DEFAULT_SECONDS;
    timerPill.textContent = fmtTime(secondsLeft);
    if (mode !== "timed") return;

    timerHandle = setInterval(() => {
      if (paused) return;
      secondsLeft -= 1;
      if (secondsLeft < 0) secondsLeft = 0;
      timerPill.textContent = fmtTime(secondsLeft);
      if (secondsLeft === 0) {
        paused = true;
        openModal("Timed session ended", "You can stop here, or continue for 5 minutes.");
      }
    }, 1000);
  }

  function openModal(title, text) {
    modalTitle.textContent = title;
    modalText.textContent = text;
    overlay.style.display = "flex";
    stopBtn.focus();
  }

  function closeModal() {
    overlay.style.display = "none";
    paused = false;
    continueBtn.textContent = "Continue";
    continueBtn.style.display = "inline-block";
    cardEl.focus();
  }

  function checkAllGreenEnd() {
    if (mode !== "allgreen") return;
    if (countGreen() >= sessionCards.length && sessionCards.length > 0) {
      paused = true;
      openModal("All green", "This session is complete. You can stop here, or restart the session.");
      continueBtn.textContent = "Restart";
    } else {
      continueBtn.textContent = "Continue";
    }
  }

  // Wiring
  deckSelect.addEventListener("change", () => {
    currentDeckDef = JSON.parse(deckSelect.value);
    resetSessionState(deckCardsFromDef(currentDeckDef));
    mode = getMode();
    paused = false;
    closeModal();
    if (mode === "timed") startTimer();
    else { stopTimer(); timerPill.textContent = "All green"; }
  });

  promptBtn.addEventListener("click", () => {
    promptBackFirst = !promptBackFirst;
    setPromptUI();
    showingBack = false;
    renderCard();
    cardEl.focus();
  });

  textBtn.addEventListener("click", () => {
    bigText = !bigText;
    setTextUI();
    cardEl.focus();
  });

  showRemaining.addEventListener("change", updateRemainingVisibility);
  nextBtn.addEventListener("click", nextCard);
  flipBtn.addEventListener("click", flipCard);
  easyBtn.addEventListener("click", markEasy);
  hardBtn.addEventListener("click", markHard);

  restartBtn.addEventListener("click", () => {
    if (!currentDeckDef) return;
    resetSessionState(deckCardsFromDef(currentDeckDef));
    mode = getMode();
    paused = false;
    closeModal();
    if (mode === "timed") startTimer();
    else { stopTimer(); timerPill.textContent = "All green"; }
  });

  modeRadios.forEach(r => r.addEventListener("change", () => {
    mode = getMode();
    paused = false;
    closeModal();
    if (mode === "timed") startTimer();
    else { stopTimer(); timerPill.textContent = "All green"; }
    renderAll();
  }));

  cardEl.addEventListener("click", flipCard);
  cardEl.addEventListener("keydown", (e) => { if (e.key === "Enter") flipCard(); });

  document.addEventListener("keydown", (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || (e.target && e.target.isContentEditable)) return;

    if (e.code === "Space") { e.preventDefault(); flipCard(); }
    else if (e.code === "ArrowRight") { e.preventDefault(); nextCard(); }
    else if (e.code === "ArrowLeft") { e.preventDefault(); prevCard(); }
    else if (e.code === "ArrowUp") { e.preventDefault(); markEasy(); }
    else if (e.code === "ArrowDown") { e.preventDefault(); markHard(); }
  });

  stopBtn.addEventListener("click", () => {
    closeModal();
    stopTimer();
    paused = true;
    openModal("Stopped", "Session stopped. Use Restart session to begin again.");
    continueBtn.style.display = "none";
  });

  continueBtn.addEventListener("click", () => {
    if (mode === "timed") {
      secondsLeft = 5 * 60;
      timerPill.textContent = fmtTime(secondsLeft);
      closeModal();
    } else if (mode === "allgreen") {
      if (currentDeckDef) resetSessionState(deckCardsFromDef(currentDeckDef));
      closeModal();
    } else {
      closeModal();
    }
  });

  // Init
  (async function initApp() {
    try {
      await loadDeckIndexAndData();
    } catch (err) {
      console.error(err);
      timerPill.textContent = "Deck load error";
    }

    populateDeckSelect();
    setPromptUI();
    setTextUI();
    updateRemainingVisibility();

    const firstOpt = deckSelect.querySelector("option");
    if (firstOpt) {
      deckSelect.value = firstOpt.value;
      currentDeckDef = JSON.parse(deckSelect.value);
      resetSessionState(deckCardsFromDef(currentDeckDef));
    }

    mode = getMode();
    if (mode === "timed") startTimer();
    else { stopTimer(); timerPill.textContent = "All green"; }

    renderAll();
  })();

</script>
</body>
</html>
